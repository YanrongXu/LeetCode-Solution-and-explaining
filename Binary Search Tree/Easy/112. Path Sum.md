Given the `root` of a binary tree and an integer `targetSum`, return `true`
if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals `targetSum`.

A <strong>leaf</strong> is a node with no children.

#### Example 1:
![example 1](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)
```
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
```

#### Example 2:
![example 2](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)
```
Input: root = [1,2,3], targetSum = 5
Output: false
```

#### Example 3:
```
Input: root = [1,2], targetSum = 0
Output: false
```

#### Constraints:
  * The number of nodes in the tree is in the range `[0, 5000]`.
  * -1000 <= Node.val <= 1000
  * -1000 <= targetSum <= 1000
  
### Iterative
```python
Step:
1.  check if there a root
2.  create a queue to store the root, and the totalSum, which are the root.val now
3.  loop through the queue
  1.  pop the current root node and the total sum out of queue
  2.  check if there is not both left and child node, and the totoal sum is equal to targetsum
    1.  return true
  3.  if there is left child node:
    1.  append the left child node and left child node.val + totalsum to the queue
  4.  if there is right child node:
    1.  append the right child node and right child node.val + totalsum to the queue
  5. return False
  
def hasPathSum(self, root, targetSum):
    if not root:
        return False
    
    queue = [(root, root.val)]
    while queue:
        node, totalSum = queue.pop(0)
        if not node.left and not node.right and totalSum == targetSum:
            return True
        if node.left:
            queue.append((node.left, totalSum + node.left.val))
        if node.right:
            queue.append((node.right, totalSum + node.right.val))
        return False
```
