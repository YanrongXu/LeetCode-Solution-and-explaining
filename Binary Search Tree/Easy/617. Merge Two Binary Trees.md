You are given two binary trees `root1` and `root2`.
  
Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees, into a new binary tree. The merge rules is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.

Return the merged tree.

<strong>Note:</strong> The merge process must start from the root nodes of both trees.

#### Example 1:
![example 1](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)
```
Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]
```

#### Example 2:
```
Input: root1 = [1], root2 = [1,2]
Output: [2,2]
```

#### Constraints:
  * The number of nodes in both trees is in the range `[0, 2000]`
  * `-10^4 <= Node.val <= 10^4`
  
### Recursive
```python
Step:
1.  check if not root1:
  1. return root2
2.  check if not root2:
  1.  return root1
3.  add root2.val to root1.val
4.  find root1.left by call mergeTrees fucntion to root1.left, and root2.left
5.  find root1.right by call mergeTrees function to root1.right and root2.right
6.  return root1

def mergeTrees(self, root1, root2);
    if not root1:
        return root2
    if not root2:
        return root1
    
    root1.val += root2.val
    root1.left = self.mergeTrees(root1.left, root2.left)
    root1.right = self.mergeTrees(root1.right, root2.right)
    
    return root1
```
